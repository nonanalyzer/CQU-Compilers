# **IR 定义**

出于实验测评需要，我们针对实验Sysy语言设计并提供统一的IR框架。为简化大家工作，我们只设计一层 IR，并给出了严格的 IR 语义。所有IR均采用四元式的形式，即 **（opcode，des，operand1，operand2）**

我们把 IR 分为几种类型，分别进行说明：
- 变量定义IR
- 变量赋值IR
- 算术运算IR
- 逻辑运算IR
- 访存与指针运算IR
- 类型转化IR
- 调用返回IR
- 跳转IR

## **变量定义IR**

### **def**

用于定义整形变量，第一个操作数为立即数或变量，第二个操作数不使用，结果为被赋值变量。示例如下：

`int a = 8;`  =>  `def a, 8`

### **fdef**

用于定义浮点数变量，操作数与结果含义与`def`相同。示例如下：

`float a = 8.0;`  =>  `fdef a, 8.0`

> 注：
>
> 此处的变量是指在程序中定义的变量，在后面指令描述中变量包括程序中定义的变量与为生成 IR 而产生的临时变量等。在 IR 测评机中，认为**一个出现在 des 位置的且没有被分配空间的变量**即为一个新的变量，会自动为其分配空间，所以在 IR 中其实 def/fdef 并不是定义一个新变量的唯一方法（当然你可以用自己喜欢的方法去实现）


## **变量赋值IR**

### **mov**

用于整型变量间赋值情况，如临时变量给程序变量赋值或程序变量给临时变量赋值。第一个操作数为赋值变量，第二个操作数不使用，结果为被赋值变量。示例如下：

`int a = in[2];`

将生成如下IR：

`load t1, in, 2`

`mov a, t1`

优化后也可以合并为一条:
`load a, in, 2`

`load` IR 在下文说明。

### **fmov**

用于浮点型变量间赋值情况，操作数与结果含义与`mov`相同。示例如下：

`float a = fl[2];`

将生成如下IR：

`load t1, fl, 2`

`fmov a, t1`

## **算术运算IR**

### **add**

整型变量加法指令，用于两操作数均为整型变量情况。示例如下：

`a = b + c;`   =>  `add a, b, c`

### **addi**

立即数加法指令，用于两操作数均为整型且第二个操作数为立即数情况。示例如下：

`a = b + 2;`  =>  `addi, a, b, 2`

### **fadd**

浮点型变量加法指令，用于两操作数均为浮点型变量情况。示例如下：

`float b, c;`

`float a = b + c;`   =>  `fadd a, b, c`

### **sub**

整型变量减法指令，用于两操作数均为整型变量情况。示例如下：

`a = b - c;`   =>  `sub a, b, c`

### **subi**

立即数减法指令，用于两操作数均为整型且第二个操作数为立即数情况。示例如下：

`a = b - 2;`  =>  `subi, a, b, 2`

### **fsub**

浮点型变量减法指令，用于两操作数均为浮点型变量情况。示例如下：

`float b, c;`

`float a = b - c;`   =>  `fsub a, b, c`

### **mul** 

整型变量乘法指令，用于两操作数均为整型变量情况。示例如下：

`int a = b * c;`  =>  `mul a, b, c`

> 注：当有任一操作数为立即数时，建议额外生成一条 IR 指令来产生一个临时变量作为源操作数，保证 mul 的两个源操作数都是变量。（RISCV指令集中乘法不支持其中某个操作数为立即数TT，如果选择在后端处理源操作数是立即数的情况，寄存器的分配可能会麻烦一点）

### **fmul**

浮点型变量乘法指令，用于两操作数均为浮点型变量情况。示例如下：

`float b, c;`

`float a = b * c;`  =>  `fmul a, b, c`

### **div**

整型变量除法指令，用于两操作数均为整型变量情况。示例如下：

`int a = b / c;`  =>  `div a, b, c`

> 注：与`mul`相同，当有任一操作数为立即数时，建议额外生成一条 IR 指令来产生一个临时变量作为源操作数，保证 div 的两个源操作数都是变量

### **fdiv**

浮点型变量除法指令，用于两操作数均为浮点型变量情况。示例如下：

`float b, c;`

`float a = b / c;`  =>  `fdiv a, b, c`

### **mod**

整型变量取余指令，示例如下：

`int a = b % c;`  =>  `mod a, b, c`

## **逻辑运算IR**
逻辑运算 IR 的运算结果是 1/0，同时整形与浮点型的变量之间不能直接做逻辑运算

### **lss**

整型变量`<`运算，逻辑运算结果用变量表示。示例如下：

`a < b`  =>  `lss t1, a, b`

### **flss**

浮点型变量`<`运算，逻辑运算结果用变量表示。示例如下：

`float a, b;`

`a < b`  =>  `flss t1, a, b`



### **leq**

整型变量`<=`运算，逻辑运算结果用变量表示。示例如下：

`a <= b`  =>  `leq t1, a, b`

### **fleq**

浮点型变量`<=`运算，逻辑运算结果用变量表示。示例如下：

`float a, b;`

`a <= b`  =>  `fleq t1, a, b`  

### **gtr**

整型变量`>`运算，逻辑运算结果用变量表示。示例如下：

`a > b`  =>  `gtr t1, a, b`

### **fgtr**

浮点型变量`>`运算，逻辑运算结果用变量表示。示例如下：

`float a, b;`

`a > b`  =>  `fgtr t1, a, b`

### **geq**

整型变量`>=`运算，逻辑运算结果用变量表示。示例如下：

`a >= b`  =>  `geq t1, a, b`

### **fgeq**

浮点型变量`>=`运算，逻辑运算结果用变量表示。示例如下：

`float a, b;`

`a >= b`  =>  `fgeq t1, a, b`

### **eq**

整型变量`==`运算，逻辑运算结果用变量表示。示例如下：

`a == b`  =>  `eq t1, a, b`

### **feq**

浮点型变量`==`运算，逻辑运算结果用变量表示。示例如下：

`float a, b;`

`a == b`  =>  `feq t1, a, b`

### **neq**

整型变量`!=`运算，逻辑运算结果用变量表示。示例如下：

`a != b`  =>  `neq t1, a, b`

### **fneq**

浮点型变量`!=`运算，逻辑运算结果用变量表示。示例如下：

`float a, b;`

`a != b`  => `fneq t1, a, b`
  

### **_not**

变量取非运算 `!` ，第一个操作数为取非变量，第二个操作数不使用，结果为取非结果变量。示例如下：

`a = !b;`  =>  `not a, b`

### **_and**

变量与运算 `&&` ，示例如下：

`a = b && c;`       =>             `and a, b, c`

### **_or**

变量或运算 `||` ，示例如下：

`a = b || c;`       =>             `or a, b, c`

## **访存与指针运算IR**

### **alloc**

内存分配指令，用于局部数组变量声明。第一个操作数为数组长度（非栈帧移动长度），第二个操作数不使用，结果为数组名，**数组名被视为一个指针**。示例如下：

`int a[2];`  =>  `alloc a, 2`

### **load**

取数指令，这里load指从数组中取数。第一个操作数为数组名，第二个操作数为要取数所在数组下标，目的操作数为取数存放变量。示例如下：

`a = arr[2];`  =>  	`load a, arr, 2`

### **store**

存数指令，指向数组中存数。第一个操作数为数组名，第二个操作数为要存数所在数组下标，目的操作数为存入的数。示例如下：

`arr[2] = 3;`  =>  	`store 3, arr, 2`

> 注：数组初始化时每个初始化数组元素均应生成一条 `store` IR

### **getptr**
获取指针指令，这实际上是一个指针运算指令，第一个操作数为数组名，第二个操作数为数组下标，运算结果仍为指针，其值是数组名(基址)+数组下标(偏移量)之后的地址，目的操作数为存入的指针操作数。主要用于数组传参的情况，示例如下：
```C++
void f(int arr[][3]);

...

int A[3][3];
f(A[1]);
```
在传参时，**A[1]** 实际上是作为一个指针传入了函数 f，为了对这种情况进行支持，我们设计了这样一个 new_ptr = 基址(ptr) + 偏移量(int) 的IR指令，传参过程为：

`1: getptr t1, A, 3`

`2: call t2, f(t1)`

## **类型转换IR**

### **cvt_i2f**

整型变量转为浮点型变量，第一个操作数为待转换变量，结果为类型转换后变量，第二个操作数不使用。示例如下：

`int a = 2;`

`float b = a;`            =>                 `cvt_i2f b, a`

### **cvt_f2i**

浮点型变量转为整型变量，第一个操作数为待转换变量，结果为类型转换后变量，第二个操作数不使用。示例如下：

`float a = 2;`

`int b = a;`            =>                 `cvt_f2i b, a`

## **调用返回IR**

### **return**

返回指令，第一个操作数为返回值，第二个操作数与结果不使用。示例如下：

`return a;`  =>  `return a`

### **call**

函数调用指令，第一个操作数的name应为函数名，结果操作数为函数返回值，固定为一临时变量（对于无返回值函数，即使在IR中看起来像是返回了一个变量，但该临时变量后续不会被使用，不影响最终测评结果）。示例如下：
```C
int test(int a, int b);

res = test(arg1, arg2);
```
将生成如下IR：

`call t1, test(arg1, arg2)`

`mov res, t1`

> 在后端实现 **call** 和 **return** IR 时，即实现函数调用与返回功能，应该严格遵守 risc-v 的**二进制接口**和**函数调用约定**，否则将无法正确的调用库函数

## **跳转IR**

### **goto** 

跳转指令。每条IR生成都会对应一标签，`goto` IR 跳转到某个标签的 IR 处。第一个操作数为跳转条件，其为整形变量或`type = Type::null`的变量，当为整形变量时表示条件跳转（值不等于0发生跳转），否则为无条件跳转。第二个操作数不使用，目的操作数应为整形，其值为跳转相对目前pc的偏移量。示例如下：

```C
if (a < b) { 
    ...
}
a = 1;
```

将生成如下IR：

`1: lss t1, a, b`

`2: if t1 goto [pc, 2]`

`3: goto [pc, 7]`

`...`

`10: mov a, 1`

## **空 IR**

### **unuse**

生成一条带有标签但无实际含义的IR，第一个操作数、第二个操作数与结果均不使用。可用于避免某些分支跳转情况假出口跳转到未知标签。示例如下：

```C
if (a < b) { 
    return 0;
}
```

若生成如下 IR，可以保证第三条 goto IR 跳转目标一定存在：

`1: lss t1, a, b`

`2: if t1 goto [pc, 2]`

`3: goto [pc, 2]`

`4: return 0`

`5: __unuse__`

> 该 IR 的后端实现可以实现为 nop 指令或者直接忽略