# VLA

VLA（变长数组，Variable Length Array）在 C 语言中是一个很有意思、也有点曲折的特性。下面是它的发展历史：

------

## 🧠 什么是 VLA？

VLA 是指数组的大小在**运行时动态确定**，但仍然存储在栈上，不需要 `malloc` 等堆分配。

```c
void foo(int n) {
    int a[n];  // 这是 VLA
}
```

------

## 📜 VLA 的发展历程

### ✅ C99 —— 初次引入（正式支持）

- **C99 标准**第一次引入 VLA。
- 原因是：为了更方便地写一些数学、科学计算中需要“按需分配栈空间”的数组。
- 特点：
  - VLA 的大小可以是函数参数、局部变量等**运行时值**。
  - 生命周期与普通局部变量相同（函数调用结束自动释放）。

```c
// 合法：n 由参数决定
void example(int n) {
    int arr[n];
}
```

------

### ⚠️ C11 —— 改为“可选特性”（optional）

- 在 **C11 标准**中，VLA 被**降级为 optional feature**。

- 也就是说：

  > 编译器**不再被强制要求支持** VLA。

- 原因：

  - 实现起来较复杂，尤其在内存紧张或嵌入式系统中。
  - 和内存安全、栈空间控制有潜在冲突。

- 在嵌入式编程中，很多人希望禁用 VLA。

> ✅ GCC 仍默认支持 VLA，除非用 `-std=c11 -fno-vla` 显式禁用。

------

### ⛔ C23 —— VLA 彻底移除？

- C23 标准已发布，目前 **未完全移除 VLA**，但更倾向于让实现自己决定。
- 趋势上，**主流编译器依然保留对 VLA 的支持**，但在嵌入式或代码规范中经常被禁用（比如 MISRA C）。

------

## 🧪 VLA 在不同标准中的支持表

| 标准版本 | VLA 支持 | 状态说明                    |
| -------- | -------- | --------------------------- |
| C89/C90  | ❌ 不支持 | 只能用常量表达式做数组大小  |
| C99      | ✅ 支持   | 正式标准，强制支持          |
| C11      | ⚠️ 可选   | 变成 optional，编译器可禁用 |
| C17      | ⚠️ 同上   | 基于 C11，无新内容          |
| C23      | ⚠️ 模糊   | 趋势上鼓励禁用，但尚未移除  |

------

## ✅ GCC / Clang 对 VLA 的支持情况

| 编译器 | 默认支持 VLA？ | 说明                                   |
| ------ | -------------- | -------------------------------------- |
| GCC    | ✅ 默认支持     | 可用 `-fno-vla` 禁用                   |
| Clang  | ✅ 默认支持     | 同上                                   |
| MSVC   | ❌ 不支持       | Windows 平台不支持 VLA（需改用堆分配） |

------

## 🤔 为什么很多规范/项目禁用 VLA？

- 它使用的是栈空间 → 如果 `n` 太大，容易造成**栈溢出**
- 在嵌入式系统中，栈非常小
- 一些代码规范（如 MISRA C）会建议显式分配内存更安全、可控

------

## ✅ 总结

| 阶段 | VLA 状态   | 说明                           |
| ---- | ---------- | ------------------------------ |
| C99  | ✅ 正式引入 | 新特性、方便计算、科学编程     |
| C11  | ⚠️ 可选     | 为了可移植性和内存控制放宽要求 |
| C17  | ⚠️ 可选     | 没有变化                       |
| C23  | ⚠️ 弱化     | 更建议使用 safer 替代方式      |

这个问题问得非常深入，我们来一探 GCC 是**如何实现多个 VLA（变长数组）分配的底层逻辑**，也就是在函数中写了：

```c
void foo(int n, int m) {
    int a[n];
    int b[m];
}
```



GCC 是**怎么安排它们在栈上的布局**的？这个涉及到栈帧管理、对齐算法和变量地址计算，我们一步步来讲 👇

------

## ✅ GCC 实现 VLA 的**基本策略**

> **核心点：所有 VLA 都是栈上分配，分配顺序按声明顺序从高地址往低地址放（栈向下长）**
>  这个顺序是在 **声明时计算各数组大小，最后统一修改 `sp`** 来完成的。

------

## 💡 一步步来看：两个 VLA 的分配流程（GCC 内部逻辑）

以 `int a[n]; int b[m];` 为例：

### 🔶 步骤 1：计算每个数组大小（以字节为单位）

```c
size_a = n * sizeof(int);  // 即 n * 4
size_b = m * sizeof(int);  // 即 m * 4
```

------

### 🔶 步骤 2：每个数组的大小都**向上对齐到 16 字节**

> 遵循 ABI，栈上对象（特别是结构体或数组）必须至少 16 字节对齐（RISC-V 64）

GCC 用的是这样的宏：

```c
aligned_size_a = (size_a + 15) & ~15;
aligned_size_b = (size_b + 15) & ~15;
```

🔹 举例：

- 如果 `n = 3`，`size_a = 12`，对齐后变成 16
- 如果 `m = 7`，`size_b = 28`，对齐后变成 32

------

### 🔶 步骤 3：计算总共需要的栈空间

```c
total_size = aligned_size_a + aligned_size_b;
```

然后在函数开始时：

```asm
sub sp, sp, total_size
```

------

### 🔶 步骤 4：计算每个数组的地址（偏移）

```c
b_addr = sp;                            // b 是最后分配，最低地址
a_addr = sp + aligned_size_b;          // a 紧接在 b 之后
```

所以：

- `b` 位于 `sp` 开头
- `a` 紧跟其后（内存中更高地址）

------

## 📦 栈帧布局图示（sp 从高到低）：

```
                ↑ 栈高地址
                │
     [ a[n] ] ← sp + aligned_size_b
                │
     [ b[m] ] ← sp
                ↓ 栈低地址（向下）
```

------

## ✅ 例子（模拟生成的汇编片段）

我们假设 `n` 存在 `a0`，`m` 存在 `a1`：

```asm
    # 计算 size_a = n * 4，aligned
    slli t0, a0, 2
    addi t0, t0, 15
    andi t0, t0, -16     # t0 = aligned_size_a

    # 计算 size_b = m * 4，aligned
    slli t1, a1, 2
    addi t1, t1, 15
    andi t1, t1, -16     # t1 = aligned_size_b

    # 栈分配 total = t0 + t1
    add  t2, t0, t1
    sub  sp, sp, t2

    # b 的地址
    mv   s0, sp          # s0 -> b[m]
    
    # a 的地址
    add  s1, sp, t1      # s1 -> a[n]
```

------

## 🧠 编译器为什么这么做？

- **效率**：使用栈分配比堆分配快太多（只要 `sp -= size`）
- **简洁**：自动生命周期管理，函数结束自动释放
- **安全**：对齐确保不会破坏数据结构/ABI 协议
- **灵活**：可以支持多个 VLA，只需计算偏移即可

------

## 🔍 小贴士：你可以观察 GCC 的实现方式

你可以手动编译并查看中间代码：

```bash
riscv64-unknown-elf-gcc -S -O0 foo.c -o foo.s
```

或者用 `-fdump-tree-all` 查看 GCC 的内部中间表示，比如：

```bash
gcc -std=c99 -fdump-tree-original foo.c
```

------

## ✅ 总结表：GCC 分配多个 VLA 的算法核心

| 步骤       | 说明                                   |
| ---------- | -------------------------------------- |
| 计算大小   | `n * sizeof(type)`                     |
| 对齐大小   | 向上对齐到 16 字节（`(x + 15) & ~15`） |
| 总空间     | 所有 VLA 对齐后加总                    |
| 栈指针调整 | `sp -= total_size`                     |
| 地址计算   | 后声明的数组先放，前面的往高地址偏移   |
| 生命周期   | 函数退出自动回收，无需手动 free        |