段错误通常由以下几个原因导致：
1. **栈指针越界访问**：你的代码中可能还有其他指令在访问超出栈帧的内存位置
但这样还不够，因为栈帧大小是固定的，但后续可能还会有新的局部变量。更好的方案是使用动态栈分配，或者预扫描所有可能的局部变量。
现在使用固定的1024字节栈帧，这样可以避免栈溢出导致的段错误。虽然不够优雅，但能保证程序正常运行。


3. **负数偏移的处理**
**问题**：while 循环的回跳 `goto [pc, -31]` 中的负偏移量没有被正确识别和处理。

**解决**：
- 扩展数字识别逻辑，支持负号开头的数字
- 正确解析负偏移量并计算目标位置


**问题回顾**
1. **发现症状**：变量 `i` 在数组赋值后被意外修改
2. **精确定位**：通过调试输出发现 `b[2]` 与 `i` 共享内存位置
3. **汇编分析**：仔细阅读生成的汇编代码，发现数组基址计算错误
4. **根因分析**：栈变量分配逻辑中，变量被分配到错误的偏移位置
**根本原因**
原始的 `add_operand` 实现中：
```cpp
next_offset += static_cast<int>(size);  // 先增加偏移
_table[op] = next_offset;               // 再分配给变量
```
这导致变量被分配到"偏移+大小"的位置，而不是正确的"当前偏移"位置。
**解决方案**
修复后的实现：
```cpp
int current_offset = next_offset;       // 保存当前偏移
next_offset += static_cast<int>(size);  // 增加偏移为下次分配做准备
_table[op] = current_offset;            // 变量分配到当前偏移
return current_offset;
```
